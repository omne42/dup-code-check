# 竞品/相似工具速览（重复代码/克隆检测）

[English](competitors.md)

> 目标：快速定位生态里成熟方案，明确我们做“Rust 底座 + Node 发布”的差异化方向。

## 典型工具（按常见度/可落地性）

- jscpd：偏“文本/Token”重复检测，适合多语言/多目录扫描，工程落地成本低
- PMD CPD：Java 生态常见的 Copy/Paste Detector（Token 级）
- SonarQube Duplication：质量平台中的重复检测能力（多语言、平台化报告）
- Simian 等：偏通用克隆检测（更多是“已有产品形态”的参考）

## 按克隆类型（Clone Types）理解竞品能力

- Type-1：完全一致或仅格式变化（空白/注释）——我们当前 MVP 对齐这一层（更严格：仅去 whitespace）
- Type-2：变量/字面量重命名等轻微改动（通常需要 token 化）
- Type-3：增删少量语句（需要更复杂的相似度/窗口/指纹/AST）
- Type-4：语义相同结构不同（通常超出“简单重复检测”范畴）

## 学术/大规模方案（作为方法论参考）

- SourcererCC：面向大规模代码库的克隆检索思路（索引/检索）
- Deckard：偏结构化/特征向量方法（AST 特征）
- NiCad：偏规范化 + 比对的路线（更强调“规范化”策略）

## 对比维度（我们做竞品分析时建议记录）

- 粒度：文件级 / 片段级（函数/块）/ 跨文件拼接
- 归一化：仅 whitespace / 去注释 / token 化 / AST
- Clone Types 覆盖：Type-1/2/3
- 输出：可定位性（path + range）、JSON/SARIF、阈值/最小块大小
- 工程集成：CLI、CI、增量扫描、缓存、ignore 规则
- 性能：扫描速度、内存、对大仓库/多仓库的扩展方式（索引 vs 全量比对）

## 我们可以走的差异化（建议）

- Rust 做核心扫描/归一化/指纹，追求速度与可移植性
- Node 提供 CLI + npm 发布，方便在前端/全栈工程落地
- 先把“跨仓库 + 去格式影响”的文件级重复做扎实，再逐步下探到片段级克隆
